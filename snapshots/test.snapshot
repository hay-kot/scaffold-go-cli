cli-test:  (type=dir)
	.github:  (type=dir)
		ISSUE_TEMPLATE:  (type=dir)
			bug_report.yml:  (type=file)
				---
				name: Bug Report
				description: "Submit a bug for the latest version"
				title: "YOUR DESCRIPTIVE TITLE GOES HERE"
				labels: ["bug", "triage"]
				body:
				  - type: checkboxes
				    id: checks
				    attributes:
				      label: First Check
				      description: |
				        Please confirm and check all the following prior to submission. If you do not do this, your
				        issue may be closed.
				      options:
				        - label: This is not a feature request.
				          required: true
				        - label: I added a very descriptive title to this issue (title field is above this).
				          required: true
				        - label: I used the GitHub search to find a similar issue and didn't find it.
				          required: true
				  - type: textarea
				    id: description
				    attributes:
				      label: What is the issue you are experiencing?
				      placeholder: A clear and concise description of what the bug is.
				    validations:
				      required: true
				  - type: textarea
				    id: reproduction
				    attributes:
				      label: Steps to Reproduce (or failing test case)
				      placeholder: 1) ... 2) ... 3) ...
				    validations:
				      required: true
				  - type: textarea
				    id: version
				    attributes:
				      label: Package Version
				      placeholder: e.g. v0.1.1
				
			feature_request.yml:  (type=file)
				name: Feature Request
				description: "Submit a new feature request"
				title: "YOUR DESCRIPTIVE TITLE GOES HERE"
				labels: ["feature", "triage"]
				body:
				  - type: checkboxes
				    id: checks
				    attributes:
				      label: First Check
				      description: |
				        Please confirm and check all the following prior to submission. If you do not do this, your
				        issue may be closed.
				      options:
				        - label: I used the GitHub search to find a similar requests and didn't find it.
				          required: true
				  - type: textarea
				    id: problem
				    attributes:
				      label: Please provide a concise description of the problem that would be addressed by this feature.
				    validations:
				      required: true
				  - type: textarea
				    id: solution
				    attributes:
				      label: Please provide a concise description of the feature that would resolve your issue.
				    validations:
				      required: true
				  - type: textarea
				    id: considerations
				    attributes:
				      label: Please consider and list out some caveats or tradeoffs made in your design decision
				    validations:
				      required: true
				  - type: checkboxes
				    id: additional-information
				    attributes:
				      label: Additional Information
				      options:
				        - label: If this is accepted I'm willing to submit a PR to provide this feature
				        - label: If this is accepted I'm willing to help maintain this feature
				
		PULL_REQUEST_TEMPLATE.md:  (type=file)
			Fixes #
			
			## Purpose
			
			## Proposed Changes
			
			  -
			  -
			  -
			
			## Checklist
			
			- [ ] I have added tests that prove my fix is effective or that my feature works
			- [ ] I have added necessary documentation (if appropriate)
		workflows:  (type=dir)
			partial-tests.yml:  (type=file)
				name: Go Build/Test
				
				on:
				  workflow_call:
				
				jobs:
				  Go:
				    runs-on: ubuntu-latest
				    steps:
				      - uses: actions/checkout@v5
				
				      - name: Install tools
				        uses: jdx/mise-action@v2
				
				      - name: golangci-lint
				        uses: golangci/golangci-lint-action@v9
				        with:
				          version: latest
				          args: --timeout=6m
				
				      - name: Build
				        run: go build ./...
				
				      - name: Test
				        run: go test ./... -race
				
			pr.yml:  (type=file)
				name: pr
				
				on:
				  push:
				    branches:
				      - main
				  pull_request:
				    branches:
				      - main
				
				jobs:
				  backend-tests:
				    name: "Go Build/Test"
				    uses: ./.github/workflows/partial-tests.yml
				
			publish.yml:  (type=file)
				name: Build and Publish
				
				permissions:
				  contents: write # for release
				  packages: write
				
				on:
				  workflow_dispatch:
				    inputs:
				      semverbump:
				        description: "Which version to bump by"
				        required: true
				        default: "patch"
				        type: choice
				        options:
				          - patch
				          - minor
				          - major
				
				jobs:
				  backend-tests:
				    name: "Go Build/Test"
				    uses: ./.github/workflows/partial-tests.yml
				
				  tag:
				    name: "Publish Tag"
				    runs-on: ubuntu-latest
				    needs:
				      - backend-tests
				    steps:
				      - uses: actions/checkout@v6
				
				      - uses: actions-ecosystem/action-get-latest-tag@v1
				        id: get-latest-tag
				
				      - uses: actions-ecosystem/action-bump-semver@v1
				        id: bump-semver
				        with:
				          current_version: ${{ steps.get-latest-tag.outputs.tag }}
				          level: ${{ inputs.semverbump }}
				
				      - uses: actions-ecosystem/action-push-tag@v1
				        with:
				          tag: ${{ steps.bump-semver.outputs.new_version }}
				          message: "${{ steps.bump-semver.outputs.new_version }}"
				
				  goreleaser:
				    name: "Release"
				    needs:
				      - backend-tests
				      - tag
				    runs-on: ubuntu-latest
				    steps:
				      - uses: actions/checkout@v6
				        with:
				          fetch-depth: 0
				      - run: git fetch --force --tags
				      - uses: actions/setup-go@v6
				        with:
				          go-version-file: "go.mod"
				          cache: true
				      - uses: docker/login-action@v3
				        with:
				          registry: ghcr.io
				          username: ${{ github.actor }}
				          password: ${{ secrets.GITHUB_TOKEN }}
				      - uses: goreleaser/goreleaser-action@v6
				        with:
				          distribution: goreleaser
				          version: latest
				          args: release --clean
				        env:
				          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
				          HOMEBREW_TAP_GITHUB_TOKEN: ${{ secrets.HOMEBREW_TAP_GITHUB_TOKEN }}
				
	.gitignore:  (type=file)
		# If you prefer the allow list template instead of the deny list, see community template:
		# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
		#
		# Binaries for programs and plugins
		*.exe
		*.exe~
		*.dll
		*.so
		*.dylib
		
		# Test binary, built with `go test -c`
		*.test
		
		# Output of the go coverage tool, specifically when used with LiteIDE
		*.out
		
		# Dependency directories (remove the comment below to include it)
		# vendor/
		
		# Go workspace file
		go.work
		dist/
		
	.golangci.yml:  (type=file)
		version: "2"
		linters:
		  default: none
		  enable:
		    - asciicheck
		    - bodyclose
		    - depguard
		    - dogsled
		    - errcheck
		    - errorlint
		    - exhaustive
		    - gochecknoinits
		    - goconst
		    - gocritic
		    - gocyclo
		    - goprintffuncname
		    - govet
		    - ineffassign
		    - misspell
		    - nakedret
		    - revive
		    - staticcheck
		    - tagalign
		    - testifylint
		    - unconvert
		    - unused
		    - whitespace
		    - zerologlint
		  settings:
		    depguard:
		      rules:
		        main:
		          deny:
		            - pkg: io/ioutil
		              desc: |
		                Deprecated: As of Go 1.16, the same functionality is now provided by
		                package io or package os, and those implementations should be
		                preferred in new code. See the specific function documentation for
		                details.
		            - pkg: github.com/pkg/errors
		              desc: Should be replaced by standard lib errors package
		    exhaustive:
		      default-signifies-exhaustive: true
		    goconst:
		      min-len: 5
		      min-occurrences: 5
		    revive:
		      confidence: 3
		      severity: warning
		    tagalign:
		      order:
		        - json
		        - schema
		        - yaml
		        - yml
		        - toml
		        - validate
		    testifylint:
		      enable-all: true
		  exclusions:
		    generated: lax
		    paths:
		      - third_party$
		      - builtin$
		      - examples$
		issues:
		  fix: true
		formatters:
		  enable:
		    - gofumpt
		  exclusions:
		    generated: lax
		    paths:
		      - third_party$
		      - builtin$
		      - examples$
		  settings:
		    gofumpt:
		      extra-rules: false
		
	.goreleaser.yml:  (type=file)
		# This is an example .goreleaser.yml file with some sensible defaults.
		# Make sure to check the documentation at https://goreleaser.com
		version: 2
		before:
		  hooks:
		    - go mod tidy
		
		builds:
		  - env:
		      - CGO_ENABLED=0
		    goos:
		      - linux
		      - windows
		      - darwin
		    goarch:
		      - amd64
		      - arm
		      - arm64
		    goarm:
		      - "7"
		
		archives:
		  - formats: [tar.gz]
		    # this name template makes the OS and Arch compatible with the results of uname.
		    name_template: >-
		      {{ .ProjectName }}_
		      {{- title .Os }}_
		      {{- if eq .Arch "amd64" }}x86_64
		      {{- else if eq .Arch "386" }}i386
		      {{- else }}{{ .Arch }}{{ end }}
		      {{- if .Arm }}v{{ .Arm }}{{ end }}
		    # use zip for windows archives
		    format_overrides:
		      - goos: windows
		        formats: [zip]
		
		checksum:
		  name_template: "checksums.txt"
		
		snapshot:
		  version_template: "{{ incpatch .Version }}-next"
		
		changelog:
		  sort: asc
		  groups:
		    - title: Features
		      regexp: '^.*?feat(\(\w+\))??!?:.+$'
		      order: 0
		    - title: Bug Fixes
		      regexp: '^.*?fix(\(\w+\))??!?:.+$'
		      order: 1
		    - title: Documentation
		      regexp: '^.*?docs(\(\w+\))??!?:.+$'
		      order: 2
		    - title: Other
		      order: 999
		  filters:
		    exclude:
		      - "^test:"
		      - "^chore:"
		      - "^ci:"
		
		
		homebrew_casks:
		  - repository:
		      owner: "hay-kot"
		      name: "homebrew-scaffold-go-cli-tap"
		      token: "{{ .Env.HOMEBREW_TAP_GITHUB_TOKEN }}"
		    description: "A new project"
		    homepage: "https://github.com/username/project"
		    dependencies:
		      - formula: go
		        type: optional
		      - formula: git
		
		
		
		dockers:
		  - use: buildx
		    goos: linux
		    goarch: arm
		    goarm: 7
		    image_templates:
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-armv7"
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-armv7"
		    build_flag_templates:
		      - "--platform=linux/arm/v7"
		      - "--pull"
		      - "--label=org.opencontainers.image.created={{.Date}}"
		      - "--label=org.opencontainers.image.title={{.ProjectName}}"
		      - "--label=org.opencontainers.image.revision={{.FullCommit}}"
		      - "--label=org.opencontainers.image.version=v{{.Version}}"
		
		  - use: buildx
		    goos: linux
		    goarch: arm64
		    image_templates:
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-arm64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-arm64"
		    build_flag_templates:
		      - "--platform=linux/arm64"
		      - "--pull"
		      - "--label=org.opencontainers.image.created={{.Date}}"
		      - "--label=org.opencontainers.image.title={{.ProjectName}}"
		      - "--label=org.opencontainers.image.revision={{.FullCommit}}"
		      - "--label=org.opencontainers.image.version=v{{.Version}}"
		
		  - use: buildx
		    goos: linux
		    goarch: amd64
		    image_templates:
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-amd64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-amd64"
		    build_flag_templates:
		      - "--platform=linux/amd64"
		      - "--pull"
		      - "--label=org.opencontainers.image.created={{.Date}}"
		      - "--label=org.opencontainers.image.title={{.ProjectName}}"
		      - "--label=org.opencontainers.image.revision={{.FullCommit}}"
		      - "--label=org.opencontainers.image.version=v{{.Version}}"
		
		docker_manifests:
		  - name_template: "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}"
		    image_templates:
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-amd64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-arm64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:v{{ .Version }}-armv7"
		  - name_template: "ghcr.io/hay-kot/scaffold-go-cli:latest"
		    image_templates:
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-amd64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-arm64"
		      - "ghcr.io/hay-kot/scaffold-go-cli:latest-armv7"
		
		
		#
		#--------------------------------------------------------------------------------------------------
		# Meta
		#
		# The lines beneath this are called `modelines`. See `:help modeline`
		# Feel free to remove those if you don't want/use them.
		# yaml-language-server: $schema=https://goreleaser.com/static/schema.json
		# vim: set ts=2 sw=2 tw=0 fo=cnqoj
		
	.scaffold:  (type=dir)
		command:  (type=dir)
			scaffold.yaml:  (type=file)
				# yaml-language-server: $schema=https://hay-kot.github.io/scaffold/schema.json
				questions:
				  - name: "command_name"
				    prompt:
				      message: "Command Name"
				      description: "kebab-case command name"
				    validate:
				      required: true
				      match:
				        regex: "^[a-z]+(-[a-z]+)*$"
				        message: "must be kebab-case"
				
				rewrites:
				  - from: templates/internal/commands/command.go
				    to: "internal/commands/{{ .Scaffold.command_name }}.go"
				
				inject:
				  - name: "register command"
				    path: main.go
				    at: "// +scaffold:command:register"
				    mode: after
				    template: |
				      app = commands.New{{ .Scaffold.command_name | toPascalCase }}Cmd(flags).Register(app)
				
				presets:
				  default:
				    command_name: "example"
				
			templates:  (type=dir)
				internal:  (type=dir)
					commands:  (type=dir)
						command.go:  (type=file)
							package commands
							
							import (
								"context"
								"fmt"
							
								"github.com/rs/zerolog/log"
								"github.com/urfave/cli/v3"
							)
							
							// {{ .Scaffold.command_name | toPascalCase }}Cmd implements the {{ .Scaffold.command_name }} command
							type {{ .Scaffold.command_name | toPascalCase }}Cmd struct {
								flags *Flags
							}
							
							// New{{ .Scaffold.command_name | toPascalCase }}Cmd creates a new {{ .Scaffold.command_name }} command
							func New{{ .Scaffold.command_name | toPascalCase }}Cmd(flags *Flags) *{{ .Scaffold.command_name | toPascalCase }}Cmd {
								return &{{ .Scaffold.command_name | toPascalCase }}Cmd{flags: flags}
							}
							
							// Register adds the {{ .Scaffold.command_name }} command to the application
							func (cmd *{{ .Scaffold.command_name | toPascalCase }}Cmd) Register(app *cli.Command) *cli.Command {
								app.Commands = append(app.Commands, &cli.Command{
									Name:  "{{ .Scaffold.command_name }}",
									Usage: "{{ .Scaffold.command_name }} command",
									Flags: []cli.Flag{
										// Add command-specific flags here
									},
									Action: cmd.run,
								})
							
								return app
							}
							
							func (cmd *{{ .Scaffold.command_name | toPascalCase }}Cmd) run(ctx context.Context, c *cli.Command) error {
								log.Info().Msg("running {{ .Scaffold.command_name }} command")
							
								fmt.Println("Hello World!")
							
								return nil
							}
							
	Dockerfile:  (type=file)
		FROM gcr.io/distroless/static
		ENTRYPOINT ["/project"]
		COPY project /
		
	HOMEBREW_SETUP.md:  (type=file)
		# Homebrew Tap Setup
		
		This project is configured to publish to a Homebrew tap via GoReleaser. Follow these steps to set it up.
		
		## 1. Create the Tap Repository
		
		Create a new GitHub repository named `homebrew-scaffold-go-cli-tap` under the `hay-kot` account. This repository will hold the Homebrew cask definitions that GoReleaser publishes.
		
		## 2. Generate a Personal Access Token (PAT)
		
		GoReleaser needs a PAT with write access to the tap repository (separate from `GITHUB_TOKEN` which is scoped to the source repo).
		
		1. Go to **GitHub Settings > Developer Settings > Personal Access Tokens > Fine-grained tokens**
		2. Create a new token with:
		   - **Repository access**: Select the `homebrew-scaffold-go-cli-tap` repository
		   - **Permissions**: Contents (Read and write)
		3. Copy the generated token
		
		## 3. Add the Secret to Your Source Repository
		
		1. Go to your source repository **Settings > Secrets and variables > Actions**
		2. Click **New repository secret**
		3. Name: `HOMEBREW_TAP_GITHUB_TOKEN`
		4. Value: Paste the PAT from the previous step
		
		## 4. Verify
		
		After the next release, GoReleaser will push a cask definition to your tap repository. Users can then install with:
		
		```sh
		brew tap hay-kot/scaffold-go-cli-tap
		brew install project
		```
		
		## References
		
		- [GoReleaser Homebrew Casks](https://goreleaser.com/customization/homebrew_casks/)
		
	LICENSE:  (type=file)
		MIT License
		
		Copyright (c) 2026-02-16, John Doe
		
		Permission is hereby granted, free of charge, to any person obtaining a copy
		of this software and associated documentation files (the "Software"), to deal
		in the Software without restriction, including without limitation the rights
		to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
		copies of the Software, and to permit persons to whom the Software is
		furnished to do so, subject to the following conditions:
		
		The above copyright notice and this permission notice shall be included in all
		copies or substantial portions of the Software.
		
		THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
		IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
		FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
		AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
		LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
		OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
		SOFTWARE.
		
	README.md:  (type=file)
		# cli-test
		
		A new project
		
		## Installation
		
		```bash
		go install github.com/username/project
		```
		
		## Usage
		
		TODO
		
	go.mod:  (type=file)
		module github.com/username/project
		
		go 1.26
		
		require (
			github.com/rs/zerolog v1.33.0
			github.com/urfave/cli/v3 v3.6.2
		)
		
		require (
			github.com/mattn/go-colorable v0.1.14 // indirect
			github.com/mattn/go-isatty v0.0.20 // indirect
			golang.org/x/sys v0.30.0 // indirect
		)
		
	go.sum:  (type=file)
		github.com/coreos/go-systemd/v22 v22.5.0/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=
		github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
		github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
		github.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=
		github.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=
		github.com/mattn/go-colorable v0.1.14 h1:9A9LHSqF/7dyVVX6g0U9cwm9pG3kP9gSzcuIPHPsaIE=
		github.com/mattn/go-colorable v0.1.14/go.mod h1:6LmQG8QLFO4G5z1gPvYEzlUgJ2wF+stgPZH1UqBm1s8=
		github.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=
		github.com/mattn/go-isatty v0.0.19/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
		github.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=
		github.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=
		github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
		github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
		github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
		github.com/rs/xid v1.5.0/go.mod h1:trrq9SKmegXys3aeAKXMUTdJsYXVwGY3RLcfgqegfbg=
		github.com/rs/zerolog v1.33.0 h1:1cU2KZkvPxNyfgEmhHAz/1A9Bz+llsdYzklWFzgp0r8=
		github.com/rs/zerolog v1.33.0/go.mod h1:/7mN4D5sKwJLZQ2b/znpjC3/GQWY/xaDXUM0kKWRHss=
		github.com/stretchr/testify v1.11.1 h1:7s2iGBzp5EwR7/aIZr8ao5+dra3wiQyKjjFuvgVKu7U=
		github.com/stretchr/testify v1.11.1/go.mod h1:wZwfW3scLgRK+23gO65QZefKpKQRnfz6sD981Nm4B6U=
		github.com/urfave/cli/v3 v3.6.2 h1:lQuqiPrZ1cIz8hz+HcrG0TNZFxU70dPZ3Yl+pSrH9A8=
		github.com/urfave/cli/v3 v3.6.2/go.mod h1:ysVLtOEmg2tOy6PknnYVhDoouyC/6N42TMeoMzskhso=
		golang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
		golang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
		golang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
		golang.org/x/sys v0.30.0 h1:QjkSwP/36a20jFYWkSue1YwXzLmsV5Gfq7Eiy72C1uc=
		golang.org/x/sys v0.30.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
		gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
		gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
		
	internal:  (type=dir)
		commands:  (type=dir)
			flags.go:  (type=file)
				package commands
				
				// Flags holds global flags shared across all commands
				type Flags struct {
					LogLevel string
					NoColor  bool
				}
				
			goodbye.go:  (type=file)
				package commands
				
				import (
					"context"
					"fmt"
				
					"github.com/rs/zerolog/log"
					"github.com/urfave/cli/v3"
				)
				
				// GoodbyeCmd implements the goodbye command
				type GoodbyeCmd struct {
					flags *Flags
				}
				
				// NewGoodbyeCmd creates a new goodbye command
				func NewGoodbyeCmd(flags *Flags) *GoodbyeCmd {
					return &GoodbyeCmd{flags: flags}
				}
				
				// Register adds the goodbye command to the application
				func (cmd *GoodbyeCmd) Register(app *cli.Command) *cli.Command {
					app.Commands = append(app.Commands, &cli.Command{
						Name:  "goodbye",
						Usage: "goodbye command",
						Flags: []cli.Flag{
							// Add command-specific flags here
						},
						Action: cmd.run,
					})
				
					return app
				}
				
				func (cmd *GoodbyeCmd) run(ctx context.Context, c *cli.Command) error {
					log.Info().Msg("running goodbye command")
				
					fmt.Println("Hello World!")
				
					return nil
				}
				
			hello.go:  (type=file)
				package commands
				
				import (
					"context"
					"fmt"
				
					"github.com/rs/zerolog/log"
					"github.com/urfave/cli/v3"
				)
				
				// HelloCmd implements the hello command
				type HelloCmd struct {
					flags *Flags
				}
				
				// NewHelloCmd creates a new hello command
				func NewHelloCmd(flags *Flags) *HelloCmd {
					return &HelloCmd{flags: flags}
				}
				
				// Register adds the hello command to the application
				func (cmd *HelloCmd) Register(app *cli.Command) *cli.Command {
					app.Commands = append(app.Commands, &cli.Command{
						Name:  "hello",
						Usage: "hello command",
						Flags: []cli.Flag{
							// Add command-specific flags here
						},
						Action: cmd.run,
					})
				
					return app
				}
				
				func (cmd *HelloCmd) run(ctx context.Context, c *cli.Command) error {
					log.Info().Msg("running hello command")
				
					fmt.Println("Hello World!")
				
					return nil
				}
				
		paths:  (type=dir)
			paths.go:  (type=file)
				package paths
				
				import (
					"os"
					"path/filepath"
				)
				
				const appName = "project"
				
				// ConfigDir returns the XDG config directory for the application.
				// Uses $XDG_CONFIG_HOME/<app> or falls back to ~/.config/<app>.
				func ConfigDir() string {
					if dir := os.Getenv("XDG_CONFIG_HOME"); dir != "" {
						return filepath.Join(dir, appName)
					}
				
					home, _ := os.UserHomeDir()
					return filepath.Join(home, ".config", appName)
				}
				
				// DataDir returns the XDG data directory for the application.
				// Uses $XDG_DATA_HOME/<app> or falls back to ~/.local/share/<app>.
				func DataDir() string {
					if dir := os.Getenv("XDG_DATA_HOME"); dir != "" {
						return filepath.Join(dir, appName)
					}
				
					home, _ := os.UserHomeDir()
					return filepath.Join(home, ".local", "share", appName)
				}
				
				// CacheDir returns the XDG cache directory for the application.
				// Uses $XDG_CACHE_HOME/<app> or falls back to ~/.cache/<app>.
				func CacheDir() string {
					if dir := os.Getenv("XDG_CACHE_HOME"); dir != "" {
						return filepath.Join(dir, appName)
					}
				
					home, _ := os.UserHomeDir()
					return filepath.Join(home, ".cache", appName)
				}
				
	main.go:  (type=file)
		package main
		
		import (
			"context"
			"fmt"
			"os"
			"os/signal"
			"runtime/debug"
			"syscall"
		
			"github.com/rs/zerolog"
			"github.com/rs/zerolog/log"
			"github.com/urfave/cli/v3"
		
			"github.com/username/project/internal/commands"
		)
		
		var (
			// Build information. Populated at build-time via -ldflags flag.
			version = "dev"
			commit  = "HEAD"
			date    = "now"
		)
		
		func build() string {
			if version == "dev" {
				if info, ok := debug.ReadBuildInfo(); ok {
					version = info.Main.Version
					for _, s := range info.Settings {
						switch s.Key {
						case "vcs.revision":
							commit = s.Value
						case "vcs.time":
							date = s.Value
						}
					}
				}
			}
		
			short := commit
			if len(commit) > 7 {
				short = commit[:7]
			}
		
			return fmt.Sprintf("%s (%s) %s", version, short, date)
		}
		func setupLogger(level string, noColor bool) error {
			parsedLevel, err := zerolog.ParseLevel(level)
			if err != nil {
				return fmt.Errorf("failed to parse log level: %w", err)
			}
		
			log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr, NoColor: noColor}).Level(parsedLevel)
		
			return nil
		}
		
		func main() {
			os.Exit(run())
		}
		
		func run() int {
			log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stderr})
		
			flags := &commands.Flags{}
		
			app := &cli.Command{
				Name:                  "cli-test",
				Usage:                 `A new project`,
				Version:               build(),
				EnableShellCompletion: true,
				Flags: []cli.Flag{
					&cli.StringFlag{
						Name:        "log-level",
						Usage:       "log level (debug, info, warn, error, fatal, panic)",
						Sources:     cli.EnvVars("LOG_LEVEL"),
						Value:       "info",
						Destination: &flags.LogLevel,
					},
					&cli.BoolFlag{
						Name:        "no-color",
						Usage:       "disable colored output",
						Sources:     cli.EnvVars("NO_COLOR"),
						Destination: &flags.NoColor,
					},
				},
				Before: func(ctx context.Context, c *cli.Command) (context.Context, error) {
					if err := setupLogger(flags.LogLevel, flags.NoColor); err != nil {
						return ctx, err
					}
		
					return ctx, nil
				},
			}
			app = commands.NewHelloCmd(flags).Register(app)
			app = commands.NewGoodbyeCmd(flags).Register(app)
			// +scaffold:command:register
		
			ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
			defer stop()
		
			if err := app.Run(ctx, os.Args); err != nil {
				colorRed := "\033[38;2;215;95;107m"
				colorGray := "\033[38;2;163;163;163m"
				colorReset := "\033[0m"
				if flags.NoColor {
					colorRed = ""
					colorGray = ""
					colorReset = ""
				}
				fmt.Fprintf(os.Stderr, "\n%s╭ Error%s\n%s│%s %s%s%s\n%s╵%s\n",
					colorRed, colorReset,
					colorRed, colorReset, colorGray, err.Error(), colorReset,
					colorRed, colorReset,
				)
				return 1
			}
		
			return 0
		}
		
	mise.toml:  (type=file)
		[tools]
		go = "latest"
		golangci-lint = "latest"
		goreleaser = "latest"
		"github:gotestyourself/gotestsum" = "latest"
		
		[env]
		LOG_LEVEL = "debug"
		
		[tasks.run]
		description = "Run the main application"
		run = "go run ."
		
		[tasks.build]
		description = "Build the binary with goreleaser"
		run = "goreleaser build --snapshot --clean"
		
		[tasks.test]
		description = "Run all go tests using gotestsum"
		run = "gotestsum ./..."
		
		[tasks."test:watch"]
		description = "Run all go tests in watch mode"
		run = "gotestsum --watch -- -v ./..."
		
		[tasks.coverage]
		description = "Run tests with race detection and coverage"
		run = "go test -race -coverprofile=coverage.out -covermode=atomic ./... -v -cover"
		
		[tasks.tidy]
		description = "Run go mod tidy"
		run = "go mod tidy"
		
		[tasks.lint]
		description = "Run golangci-lint"
		run = "golangci-lint run ./..."
		
		[tasks.fmt]
		description = "Run golangci-lint fmt"
		run = "golangci-lint fmt"
		
		[tasks.check]
		description = "Run all checks for PRs (tidy, lint, test)"
		run = [
		    { task = "tidy" },
		    { task = "lint" },
		    { task = "test" },
		]
		
	renovate.json:  (type=file)
		{
		    "$schema": "https://docs.renovatebot.com/renovate-schema.json",
		    "extends": [
		        "config:base"
		    ],
		    "postUpdateOptions": [
		        "gomodTidy"
		    ]
		}

